<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Binaural Focus Synth — Ultra</title>
<style>
  :root { --bg:#0b1020; --fg:#e8f0ff; --muted:#93a4c8; --accent:#8ad; }
  * { box-sizing:border-box }
  body { margin:0; font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
         background:linear-gradient(180deg,#0b1020 0%,#0e1836 100%); color:var(--fg); }
  header { padding:1.1rem 1.2rem; border-bottom:1px solid #1d2a4a; display:flex; gap:.8rem; align-items:center; flex-wrap:wrap; }
  h1 { font-size:1.1rem; margin:0; color:#cde0ff; letter-spacing:.02em; }
  main { max-width:1100px; margin:0 auto; padding:1rem; display:grid; gap:1rem; }
  .row { display:grid; grid-template-columns:repeat(auto-fit,minmax(260px,1fr)); gap:1rem; }
  fieldset { border:1px solid #1d2a4a; border-radius:12px; padding:1rem; background:#0e1630aa; }
  legend { padding:0 .4rem; color:#b8c9f2; }
  label { display:flex; justify-content:space-between; align-items:center; font-size:.92rem; color:var(--muted); margin:.35rem 0; gap:.75rem; }
  input[type="range"]{ width:55% } input,select{ background:#0e1c3d; border:1px solid #223461; color:var(--fg); border-radius:8px; padding:.35rem .5rem; }
  button{ background:#152a5c; color:#e7f1ff; border:1px solid #274a9a; border-radius:10px; padding:.55rem .8rem; cursor:pointer }
  button:hover{ filter:brightness(1.1) }
  button.recording{ background:#5b1531; border-color:#c93a68; color:#ffe6f0 }
  .pill { font-size:.8rem; color:#bcd3ff; background:#11224a; padding:.15rem .45rem; border-radius:999px; border:1px solid #274a9a; }
  .muted{ color:#9fb1d9; font-size:.9rem }
  .meter{ height:6px; background:#101b36; border:1px solid #243a6f; border-radius:999px; overflow:hidden }
  .meter>div{ height:100%; width:0%; background:linear-gradient(90deg,#6ea8ff,#a1c2ff) }
  footer{ text-align:center; padding:1rem; color:#8ea5d6; font-size:.85rem }
  .split{ display:flex; gap:.5rem; align-items:center; flex-wrap:wrap }
</style>
</head>
<body>
  <header>
    <h1>Binaural Focus Synth — Ultra</h1>
    <span class="pill">Tempo adjustable (default 120 BPM)</span>
    <span class="pill">Bass hits every beat</span>
    <div style="margin-left:auto; display:flex; gap:.5rem;">
      <button id="startBtn">Start</button>
      <button id="stopBtn" disabled>Stop</button>
    </div>
  </header>

  <main>
    <div class="row">
      <fieldset>
        <legend>Tempo & Presets</legend>
        <label>Tempo (BPM)
          <input id="bpm" type="range" min="60" max="180" step="1" value="120" />
        </label>
        <div class="split" style="margin:.2rem 0 .5rem;">
          <select id="preset">
            <option value="calm">Calm 8 Hz / C major / soft pad</option>
            <option value="steady">Steady 10 Hz / A minor / mellow</option>
            <option value="alert">Alert 14 Hz / D dorian / brighter</option>
            <option value="groove">Groove 12 Hz / G mixolydian / warm</option>
          </select>
          <button id="applyPreset">Apply</button>
        </div>
        <div class="muted">BPM adjusts bass hit rate. 120 BPM = 2 hits/sec.</div>
      </fieldset>

      <fieldset>
        <legend>Binaural Carrier</legend>
        <label>Binaural preset
          <select id="binauralPreset">
            <option value="custom" selected>Custom</option>
            <option value="delta">Deep Sleep — 2 Hz (delta)</option>
            <option value="theta">Meditation — 6 Hz (theta)</option>
            <option value="alpha">Relaxation — 10 Hz (alpha)</option>
            <option value="beta">Focus — 18 Hz (beta)</option>
            <option value="gamma">Clarity — 40 Hz (gamma)</option>
          </select>
        </label>
        <label>Carrier freq (Hz)
          <input id="carrier" type="range" min="100" max="600" step="1" value="220" />
        </label>
        <label>Beat freq (Hz) <span class="muted">(L/R difference)</span>
          <input id="beat" type="range" min="1" max="40" step="0.5" value="10" />
        </label>
        <label>Carrier shape
          <select id="carrierWave">
            <option value="sine" selected>sine</option>
            <option value="triangle">triangle</option>
            <option value="square">square</option>
            <option value="sawtooth">saw</option>
          </select>
        </label>
        <label>Carrier level
          <input id="carrierGain" type="range" min="0" max="1" step="0.01" value="0.22" />
        </label>
      </fieldset>

      <fieldset>
        <legend>Harmony & Bass</legend>
        <label>Key <select id="keySelect"></select></label>
        <label>Scale
          <select id="scaleSelect">
            <option value="major" selected>Major</option>
            <option value="minor">Minor</option>
            <option value="dorian">Dorian</option>
            <option value="mixolydian">Mixolydian</option>
          </select>
        </label>
        <label>Octave (bass) <input id="bassOct" type="range" min="1" max="4" step="1" value="2" /></label>
        <label>Bass timbre
          <select id="bassWave">
            <option value="sine">sine</option>
            <option value="triangle" selected>triangle</option>
            <option value="square">square</option>
            <option value="sawtooth">saw</option>
          </select>
        </label>
        <label>Bass level <input id="bassGain" type="range" min="0" max="1" step="0.01" value="0.35" /></label>
        <label>Lowpass tone <input id="lpCutoff" type="range" min="80" max="1000" step="1" value="360" /></label>
      </fieldset>

      <fieldset>
        <legend>Pad (Chord Wash) + LFO</legend>
        <label>Enable pad <input id="padToggle" type="checkbox" checked /></label>
        <label>Pad level <input id="padGain" type="range" min="0" max="1" step="0.01" value="0.28" /></label>
        <label>Pad brightness (LP base cutoff)
          <input id="padCutoff" type="range" min="200" max="4000" step="1" value="1200" />
        </label>
        <label>Pad shape
          <select id="padWave">
            <option value="sine">sine</option>
            <option value="triangle" selected>triangle</option>
            <option value="sawtooth">saw (airy)</option>
          </select>
        </label>
        <hr style="border:none;border-top:1px solid #243a6f;margin:.6rem 0;">
        <label>LFO rate (Hz) <input id="lfoRate" type="range" min="0.02" max="1.5" step="0.01" value="0.12" /></label>
        <label>LFO depth (Hz added) <input id="lfoDepth" type="range" min="0" max="800" step="1" value="250" /></label>
        <div class="muted">Pad LP filter is modulated: cutoff = base + LFO(depth).</div>
      </fieldset>

      <fieldset>
        <legend>Arpeggio (In-Key, Upper Register)</legend>
        <label>Enable arpeggio <input id="arpToggle" type="checkbox" checked /></label>
        <label>Arp level <input id="arpGain" type="range" min="0" max="1" step="0.01" value="0.22" /></label>
        <label>Arp density (notes/beat)
          <input id="arpDensity" type="range" min="1" max="3" step="1" value="2" />
        </label>
        <label>Arp timbre
          <select id="arpWave">
            <option value="sine">sine</option>
            <option value="triangle" selected>triangle</option>
            <option value="square">square</option>
            <option value="sawtooth">saw</option>
          </select>
        </label>
        <div class="muted">Chooses diatonic tones, avoids bass pitch-class, stays light.</div>
      </fieldset>

      <fieldset>
        <legend>Lead (Keyboard Loop)</legend>
        <label>Enable lead <input id="leadToggle" type="checkbox" checked /></label>
        <label>Lead level <input id="leadGain" type="range" min="0" max="1" step="0.01" value="0.25" /></label>
        <label>Lead waveform
          <select id="leadWave">
            <option value="sine">sine</option>
            <option value="triangle" selected>triangle</option>
            <option value="square">square</option>
            <option value="sawtooth">saw</option>
          </select>
        </label>
        <label>Lead mode
          <select id="leadMode">
            <option value="manual" selected>Keyboard loop</option>
            <option value="generative">Generative (Perlin)</option>
          </select>
        </label>
        <label>Lead octave <input id="leadOct" type="range" min="3" max="6" step="1" value="4" /></label>
        <div class="split" style="margin:.4rem 0 0;">
          <button id="leadRecord" type="button">Record Loop</button>
          <button id="leadClear" type="button">Clear Loop</button>
        </div>
        <div class="muted">Play with your keyboard (Z–M lower octave, Q–U upper). Switch to Generative for a Perlin-noise lead that phrases itself.</div>
      </fieldset>

      <fieldset>
        <legend>Drum Engine (Quasi-Random)</legend>
        <label>Enable drums <input id="drumToggle" type="checkbox" checked /></label>
        <label>Drum level <input id="drumLevel" type="range" min="0" max="1" step="0.01" value="0.4" /></label>
        <label>Pattern density <input id="drumDensity" type="range" min="0" max="1" step="0.01" value="0.32" /></label>
        <label>Fill probability <input id="drumFill" type="range" min="0" max="1" step="0.01" value="0.2" /></label>
        <label>Humanization <input id="drumHuman" type="range" min="0" max="1" step="0.01" value="0.5" /></label>
        <label>Pattern length
          <select id="drumLength">
            <option value="8">1 bar (8 steps)</option>
            <option value="16" selected>2 bars (16 steps)</option>
            <option value="32">4 bars (32 steps)</option>
          </select>
        </label>
        <div class="muted">Generates kick/snare/hat grids via van der Corput sequences with Perlin humanization.</div>
      </fieldset>

      <fieldset>
        <legend>Metronome & Echo</legend>
        <label>Enable click <input id="clickToggle" type="checkbox" /></label>
        <label>Click level <input id="clickGain" type="range" min="0" max="1" step="0.01" value="0.25" /></label>
        <hr style="border:none;border-top:1px solid #243a6f;margin:.6rem 0;">
        <label>Echo time (s) <input id="echoTime" type="range" min="0.08" max="0.6" step="0.01" value="0.24" /></label>
        <label>Echo feedback <input id="echoFB" type="range" min="0" max="0.95" step="0.01" value="0.35" /></label>
        <label>Echo tone (LP Hz) <input id="echoLP" type="range" min="800" max="6000" step="1" value="3000" /></label>
        <label>Echo send — Pad <input id="echoSendPad" type="range" min="0" max="1" step="0.01" value="0.35" /></label>
        <label>Echo send — Arp <input id="echoSendArp" type="range" min="0" max="1" step="0.01" value="0.55" /></label>
        <label>Echo send — Lead <input id="echoSendLead" type="range" min="0" max="1" step="0.01" value="0.45" /></label>
      </fieldset>

      <fieldset>
        <legend>FX & Master</legend>
        <label>Soft compression <input id="compToggle" type="checkbox" checked /></label>
        <label>Stereo width <input id="stereoWidth" type="range" min="0" max="1" step="0.01" value="0.8" /></label>
        <label>Master volume <input id="master" type="range" min="0" max="1" step="0.01" value="0.7" /></label>
        <div class="meter" title="output activity"><div id="meterBar"></div></div>
      </fieldset>
    </div>

    <section class="muted">
      <strong>What it’s doing:</strong> binaural carrier sets the beat frequency; a harmony engine picks diatonic
      progressions; bass “hits” every beat; a pad sustains triads with a slow filter LFO; an arpeggio dances in key;
      a simple echo adds space. Everything is scheduled ahead for tight timing. Listen comfortably; no medical claims.
    </section>
  </main>

  <footer>Made for deep focus & flow.</footer>

<script>
(() => {
  // ==== Helpers (music) ====
  const NOTE_NAMES = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
  const KEYS = Object.fromEntries(NOTE_NAMES.map((n,i)=>[n,i]));
  const SCALES = {
    major:[0,2,4,5,7,9,11],
    minor:[0,2,3,5,7,8,10],
    dorian:[0,2,3,5,7,9,10],
    mixolydian:[0,2,4,5,7,9,10],
  };
  const TRIADS = [ [0,2,4], [1,3,5], [2,4,6], [3,5,0], [4,6,1], [5,0,2], [6,1,3] ];
  const PROG = { 0:[5,3,4,6], 1:[4,0,6], 2:[5,3,0], 3:[4,0,1], 4:[0,5], 5:[3,4,0], 6:[4,0] };
  const KEYBOARD_DEGREES = {
    z:0, x:1, c:2, v:3, b:4, n:5, m:6,
    q:7, w:8, e:9, r:10, t:11, y:12, u:13,
    i:14, o:15, p:16, '[':17, ']':18
  };
  function midiFromKeyScaleDegree(root, scale, deg, octave=4){
    const scaleSteps = SCALES[scale] || SCALES.major;
    const stepsPerOct = scaleSteps.length;
    const wrappedIndex = ((deg % stepsPerOct) + stepsPerOct) % stepsPerOct;
    const octaveOffset = Math.floor((deg - wrappedIndex) / stepsPerOct);
    const semitoneRaw = root + scaleSteps[wrappedIndex];
    const extraOct = Math.floor(semitoneRaw / 12);
    const pitchClass = ((semitoneRaw % 12) + 12) % 12;
    const totalOctave = octave + octaveOffset + extraOct;
    return 12 * (totalOctave + 1) + pitchClass; // C4=60
  }
  function midiToFreq(m){ return 440 * Math.pow(2,(m-69)/12); }
  function clamp(v,l,h){ return Math.max(l, Math.min(h,v)); }
  function vanDerCorput(n, base=2){
    let v = 0;
    let denom = 1;
    let i = n;
    while (i > 0){
      denom *= base;
      v += (i % base) / denom;
      i = Math.floor(i / base);
    }
    return v;
  }

  // ==== Smooth noise utilities ====
  function mulberry32(seed){
    let t = seed >>> 0;
    return function(){
      t += 0x6D2B79F5;
      let r = Math.imul(t ^ t >>> 15, 1 | t);
      r ^= r + Math.imul(r ^ r >>> 7, 61 | r);
      return ((r ^ r >>> 14) >>> 0) / 4294967296;
    };
  }
  function createPerlinNoise(seed){
    const rand = mulberry32(seed);
    const p = new Uint8Array(256);
    for (let i = 0; i < 256; i++) p[i] = i;
    for (let i = 255; i > 0; i--){
      const j = Math.floor(rand() * (i + 1));
      const tmp = p[i]; p[i] = p[j]; p[j] = tmp;
    }
    const perm = new Uint8Array(512);
    for (let i = 0; i < 512; i++) perm[i] = p[i & 255];
    const fade = t => t * t * t * (t * (t * 6 - 15) + 10);
    const lerp = (t,a,b) => a + t * (b - a);
    const grad = (hash,x,y,z) => {
      const h = hash & 15;
      const u = h < 8 ? x : y;
      const v = h < 4 ? y : (h===12||h===14 ? x : z);
      return ((h & 1)===0 ? u : -u) + ((h & 2)===0 ? v : -v);
    };
    return function(x,y,z){
      const X = Math.floor(x) & 255;
      const Y = Math.floor(y) & 255;
      const Z = Math.floor(z) & 255;
      const xf = x - Math.floor(x);
      const yf = y - Math.floor(y);
      const zf = z - Math.floor(z);
      const u = fade(xf), v = fade(yf), w = fade(zf);
      const aaa = perm[X   + perm[Y   + perm[Z  ]]];
      const aba = perm[X   + perm[Y+1 + perm[Z  ]]];
      const aab = perm[X   + perm[Y   + perm[Z+1]]];
      const abb = perm[X   + perm[Y+1 + perm[Z+1]]];
      const baa = perm[X+1 + perm[Y   + perm[Z  ]]];
      const bba = perm[X+1 + perm[Y+1 + perm[Z  ]]];
      const bab = perm[X+1 + perm[Y   + perm[Z+1]]];
      const bbb = perm[X+1 + perm[Y+1 + perm[Z+1]]];
      const x1 = lerp(u, grad(aaa, xf    , yf    , zf    ), grad(baa, xf-1 , yf    , zf    ));
      const x2 = lerp(u, grad(aba, xf    , yf-1  , zf    ), grad(bba, xf-1 , yf-1  , zf    ));
      const y1 = lerp(v, x1, x2);
      const x3 = lerp(u, grad(aab, xf    , yf    , zf-1  ), grad(bab, xf-1 , yf    , zf-1  ));
      const x4 = lerp(u, grad(abb, xf    , yf-1  , zf-1  ), grad(bbb, xf-1 , yf-1  , zf-1  ));
      const y2 = lerp(v, x3, x4);
      return lerp(w, y1, y2);
    };
  }
  const noiseSeed = Math.floor(Math.random() * 0xFFFFFFFF);
  const perlinNoise = createPerlinNoise(noiseSeed);
  const noiseOffsets = {
    harmony: Math.random() * 256,
    bass: Math.random() * 256,
    arp: Math.random() * 256,
    timbre: Math.random() * 256,
    space: Math.random() * 256,
    drums: Math.random() * 256,
    drumVel: Math.random() * 256,
    drumSync: Math.random() * 256,
    drumAccent: Math.random() * 256,
    leadDensity: Math.random() * 256,
    leadContour: Math.random() * 256,
    leadLength: Math.random() * 256,
    leadVelocity: Math.random() * 256,
    leadHarmony: Math.random() * 256,
    leadGroove: Math.random() * 256,
    leadAccent: Math.random() * 256,
  };
  const noise01 = (x,y,z) => (perlinNoise(x,y,z) + 1) * 0.5;
  function streamNoise(channel, beat, rate, y=0.4, z=0.7){
    return noise01(noiseOffsets[channel] + beat * rate, y, z);
  }

  function createBrownianWalker(seed, { min=-Infinity, max=Infinity, step=1, damping=0.16, velocityMax=3 } = {}){
    const rng = mulberry32(seed);
    let position = 0;
    let velocity = 0;
    let seeded = false;
    const clampPos = v => clamp(v, min, max);
    return {
      reset(value=0){
        position = clampPos(value);
        velocity = 0;
        seeded = true;
      },
      sample({ anchor=position, bias=0, stepScale=1, registerBias=0 } = {}){
        if (!seeded) this.reset(anchor);
        const random = (rng() - 0.5) * 2;
        velocity += random * step * stepScale;
        velocity += (anchor - position) * bias;
        velocity += registerBias;
        velocity *= (1 - damping);
        velocity = clamp(velocity, -velocityMax, velocityMax);
        position += velocity;
        if (position < min){
          position = min;
          velocity = Math.abs(velocity) * 0.4;
        } else if (position > max){
          position = max;
          velocity = -Math.abs(velocity) * 0.4;
        }
        return position;
      },
      snap(value){
        position = clampPos(value);
        velocity *= 0.35;
        seeded = true;
      },
      get value(){ return position; },
      get initialized(){ return seeded; }
    };
  }

  // ==== DOM ====
  const $ = sel => document.querySelector(sel);
  const els = {
    start:$('#startBtn'), stop:$('#stopBtn'),
    bpm:$('#bpm'),
    preset:$('#preset'), applyPreset:$('#applyPreset'),
    binauralPreset:$('#binauralPreset'),
    carrier:$('#carrier'), beat:$('#beat'), carrierWave:$('#carrierWave'), carrierGain:$('#carrierGain'),
    keySelect:$('#keySelect'), scaleSelect:$('#scaleSelect'), bassOct:$('#bassOct'),
    bassWave:$('#bassWave'), bassGain:$('#bassGain'), lpCutoff:$('#lpCutoff'),
    padToggle:$('#padToggle'), padGain:$('#padGain'), padCutoff:$('#padCutoff'), padWave:$('#padWave'),
    lfoRate:$('#lfoRate'), lfoDepth:$('#lfoDepth'),
    arpToggle:$('#arpToggle'), arpGain:$('#arpGain'), arpDensity:$('#arpDensity'), arpWave:$('#arpWave'),
    leadToggle:$('#leadToggle'), leadGain:$('#leadGain'), leadWave:$('#leadWave'), leadMode:$('#leadMode'), leadOct:$('#leadOct'),
    leadRecord:$('#leadRecord'), leadClear:$('#leadClear'),
    drumToggle:$('#drumToggle'), drumLevel:$('#drumLevel'), drumDensity:$('#drumDensity'),
    drumFill:$('#drumFill'), drumHuman:$('#drumHuman'), drumLength:$('#drumLength'),
    clickToggle:$('#clickToggle'), clickGain:$('#clickGain'),
    echoTime:$('#echoTime'), echoFB:$('#echoFB'), echoLP:$('#echoLP'),
    echoSendPad:$('#echoSendPad'), echoSendArp:$('#echoSendArp'), echoSendLead:$('#echoSendLead'),
    compToggle:$('#compToggle'), stereoWidth:$('#stereoWidth'), master:$('#master'),
    meterBar:$('#meterBar')
  };
  NOTE_NAMES.forEach(n=>{ const o=document.createElement('option'); o.value=n; o.textContent=n; if(n==="C") o.selected=true; els.keySelect.appendChild(o); });

  // ==== Audio Graph ====
  let ctx, analyser, masterGain, compNode;
  let pannerL, pannerR, carrierGain, carrierLeft, carrierRight;
  let bassLP, bassBus;
  let padLP, padGain, padBus, padOscs=[];
  let lfoOsc, lfoGain; // mod padLP.frequency
  let arpBus;
  let leadBus;
  let drumBus;
  let clickBus;

  // Echo send/return
  let echoSendPad, echoSendArp, echoSendLead, echoDelay, echoFB, echoLPF, echoReturn;

  let noiseBuffer;

  // Helper to build pad voices on-demand
  function buildPadVoicesIfNeeded() {
    // Only build if missing
    if (!padOscs || padOscs.length !== 3) {
      // stop any leftovers safely
      try { padOscs?.forEach(({osc}) => osc.stop()); } catch {}
      padOscs = [];
      for (let i = 0; i < 3; i++) {
        const o = ctx.createOscillator();
        o.type = els.padWave.value;
        o.detune.value = (i - 1) * 4; // -4,0,+4 cents
        const e = ctx.createGain();
        e.gain.value = 0.0001;
        o.connect(e).connect(padLP);
        padOscs.push({ osc: o, env: e });
      }
    }
  }

  // ==== Transport / Scheduler ====
  let BPM = 120;
  let BEAT_SEC = 60 / BPM;
  let nextNoteTime = 0;
  let currentBeat = 0;
  const LOOKAHEAD = 25/1000;  // 25 ms
  const SCHEDULE_AHEAD = 0.15; // s
  let timerID = null;
  let transportStartTime = null;

  // Harmony state
  let keyRoot = KEYS["C"];
  let scaleName = "major";
  let currentChord = 0;
  let lastBassMidi = 40;
  let lastBassPitchClass = lastBassMidi % 12;
  let lastArpMidi = null;
  let lastArpDegree = 0;

  const LEAD_STEPS_PER_BEAT = 4;
  const LEAD_BARS = 16;
  const LEAD_TOTAL_STEPS = LEAD_BARS * 4 * LEAD_STEPS_PER_BEAT;
  const leadBuffer = Array.from({ length: LEAD_TOTAL_STEPS }, () => []);
  const leadState = { enabled: true, recording: false, active: new Map() };
  let leadStepCursor = 0;

  const leadGenState = {
    mode: 'manual',
    phrase: [],
    steps: 0,
    stepIndex: 0,
    repeatsRemaining: 0,
    lastDegree: 0,
    sectionIndex: 0,
    noiseCursor: Math.random() * 512,
    brownian: createBrownianWalker((noiseSeed ^ 0xB135) >>> 0, { min: -3, max: 22, step: 1.08, damping: 0.17, velocityMax: 3.6 }),
  };

  const DRUM_STEPS_PER_BEAT = 4;
  let drumPatterns = null;
  let drumPatternSteps = 16;
  let drumPatternNeedsUpdate = true;
  let drumStepCounter = 0;
  let drumCycleSeed = 0;

  function setBpm(val){
    BPM = clamp(parseInt(val,10), 40, 240);
    BEAT_SEC = 60 / BPM;
  }

  function initAudio(){
    if (ctx) return;
    ctx = new (window.AudioContext||window.webkitAudioContext)({latencyHint:"interactive"});

    analyser = ctx.createAnalyser(); analyser.fftSize = 512;
    masterGain = ctx.createGain(); masterGain.gain.value = parseFloat(els.master.value);
    compNode = ctx.createDynamicsCompressor();
    compNode.threshold.value = -18;
    compNode.knee.value = 24;
    compNode.ratio.value = 2.5;
    compNode.attack.value = 0.005;
    compNode.release.value = 0.15;

    const mixBus = ctx.createGain();
    const wireMaster = () => {
      try{ mixBus.disconnect(); }catch{}
      try{ compNode.disconnect(); }catch{}
      if (els.compToggle.checked) mixBus.connect(compNode).connect(masterGain).connect(analyser).connect(ctx.destination);
      else mixBus.connect(masterGain).connect(analyser).connect(ctx.destination);
    };
    wireMaster();
    initAudio.wireMaster = wireMaster;

    // Stereo panners for binaural
    pannerL = ctx.createStereoPanner(); pannerR = ctx.createStereoPanner();
    setStereoWidth(parseFloat(els.stereoWidth.value));

    // Carrier
    carrierGain = ctx.createGain(); carrierGain.gain.value = parseFloat(els.carrierGain.value);
    carrierLeft = ctx.createOscillator(); carrierRight = ctx.createOscillator();
    carrierLeft.type = els.carrierWave.value; carrierRight.type = els.carrierWave.value;
    setCarrierFreqs();
    const gainL = ctx.createGain(), gainR = ctx.createGain(); gainL.gain.value=1; gainR.gain.value=1;
    carrierLeft.connect(gainL).connect(pannerL).connect(carrierGain).connect(mixBus);
    carrierRight.connect(gainR).connect(pannerR).connect(carrierGain).connect(mixBus);

    // Bass
    bassLP = ctx.createBiquadFilter(); bassLP.type="lowpass"; bassLP.frequency.value = parseFloat(els.lpCutoff.value);
    bassBus = ctx.createGain(); bassBus.gain.value = parseFloat(els.bassGain.value);
    bassLP.connect(bassBus).connect(mixBus);

    // Pad + LFO
    padLP = ctx.createBiquadFilter(); padLP.type="lowpass"; padLP.frequency.value = parseFloat(els.padCutoff.value);
    padGain = ctx.createGain(); padGain.gain.value = parseFloat(els.padGain.value);
    padBus = ctx.createGain(); padBus.gain.value = 1;
    padLP.connect(padGain).connect(padBus).connect(mixBus);

    buildPadVoicesIfNeeded();
    // LFO -> padLP.frequency (summed with base)
    lfoOsc = ctx.createOscillator(); lfoOsc.type="sine"; lfoOsc.frequency.value = parseFloat(els.lfoRate.value);
    lfoGain = ctx.createGain(); lfoGain.gain.value = parseFloat(els.lfoDepth.value);
    lfoOsc.connect(lfoGain).connect(padLP.frequency);

    // Arpeggio
    arpBus = ctx.createGain(); arpBus.gain.value = parseFloat(els.arpGain.value);
    arpBus.connect(mixBus);

    // Lead
    leadBus = ctx.createGain(); leadBus.gain.value = parseFloat(els.leadGain.value);
    leadBus.connect(mixBus);

    // Drums
    drumBus = ctx.createGain(); drumBus.gain.value = parseFloat(els.drumLevel.value);
    drumBus.connect(mixBus);

    // Metronome
    clickBus = ctx.createGain(); clickBus.gain.value = parseFloat(els.clickGain.value);
    clickBus.connect(mixBus);

    // Echo network (simple feedback delay with tone)
    echoSendPad = ctx.createGain(); echoSendArp = ctx.createGain(); echoSendLead = ctx.createGain();
    echoDelay = ctx.createDelay(1.0); echoDelay.delayTime.value = parseFloat(els.echoTime.value);
    echoFB = ctx.createGain(); echoFB.gain.value = parseFloat(els.echoFB.value);
    echoLPF = ctx.createBiquadFilter(); echoLPF.type="lowpass"; echoLPF.frequency.value = parseFloat(els.echoLP.value);
    echoReturn = ctx.createGain(); // returns to master mix
    echoSendPad.gain.value = parseFloat(els.echoSendPad.value);
    echoSendArp.gain.value = parseFloat(els.echoSendArp.value);
    echoSendLead.gain.value = parseFloat(els.echoSendLead.value);

    // Route sends
    padBus.connect(echoSendPad);
    arpBus.connect(echoSendArp);
    leadBus.connect(echoSendLead);
    // Feedback loop: sends -> delay -> LPF -> feedback + return
    const echoMix = ctx.createGain(); echoMix.gain.value = 1.0;
    echoSendPad.connect(echoDelay); echoSendArp.connect(echoDelay); echoSendLead.connect(echoDelay);
    echoDelay.connect(echoLPF).connect(echoMix).connect(echoReturn).connect(mixBus);
    echoLPF.connect(echoFB).connect(echoDelay); // feedback loop

    // Start continuous sources
    const now = ctx.currentTime + 0.02;
    carrierLeft.start(now); carrierRight.start(now);
    buildPadVoicesIfNeeded();
    padOscs.forEach(({osc}) => osc.start(now));
    lfoOsc.start(now);

    // Meter
    const data = new Uint8Array(analyser.frequencyBinCount);
    (function meterLoop(){
      if (!ctx) return;
      analyser.getByteTimeDomainData(data);
      let sum=0; for (let i=0;i<data.length;i++){ const v=(data[i]-128)/128; sum+=v*v; }
      const rms = Math.sqrt(sum/data.length);
      els.meterBar.style.width = (clamp(rms*180,0,100)).toFixed(1) + "%";
      requestAnimationFrame(meterLoop);
    })();
  }

  function setCarrierFreqs(){
    if (!ctx) return;
    if (!carrierLeft || !carrierRight) return; // guard if not built yet
    const base = parseFloat(els.carrier.value), diff = parseFloat(els.beat.value);
    const t = ctx.currentTime;
    try {
      carrierLeft.frequency.setValueAtTime(base - diff/2, t);
      carrierRight.frequency.setValueAtTime(base + diff/2, t);
    } catch(e) {
      // If oscillators haven't started yet (or were stopped), just bail gracefully.
    }
  }
  function setStereoWidth(w){ if(ctx){ pannerL.pan.value=-clamp(w,0,1); pannerR.pan.value=+clamp(w,0,1);} }

  // ==== Musical choices ====
  function nextChordIndex(prev, beat){
    const c = PROG[prev] || PROG[0];
    const sorted = c.slice().sort((a,b)=>Math.abs(a-prev)-Math.abs(b-prev));
    const drift = streamNoise('harmony', beat, 0.045, 0.16, 0.55);
    if (drift < 0.55) return sorted[0];
    const tension = streamNoise('harmony', beat, 0.032, 0.72, 0.21);
    const idx = Math.min(c.length - 1, Math.floor(tension * c.length));
    return c[idx];
  }
  function pickBassMidi(chordIndex, beat){
    const triad = TRIADS[chordIndex];
    const roll = streamNoise('bass', beat, 0.082, 0.28, 0.63);
    const pick = roll < 0.5 ? triad[0] : (roll < 0.82 ? triad[2] : triad[1]);
    const octave = parseInt(els.bassOct.value,10);
    let m = midiFromKeyScaleDegree(keyRoot, scaleName, pick, octave+1);
    if (streamNoise('bass', beat, 0.018, 0.61, 0.48) < 0.18) m -= 12;
    while (m > 57) m -= 12;
    while (m < 40) m += 12;
    if (Math.abs(m-lastBassMidi) > 7){ m += (m>lastBassMidi)?-12:+12; }
    lastBassMidi = m; lastBassPitchClass = m % 12;
    return m;
  }

  // pick an arpeggio MIDI: diatonic, avoid current bass pitch-class, upper register
  function pickArpMidi(chordIndex, beat){
    const degrees = [0,2,4,6,1,3,5];
    const contour = streamNoise('arp', beat, 0.105, 0.44, 0.31);
    let deg = degrees[Math.min(degrees.length-1, Math.floor(contour * degrees.length))];
    const directional = streamNoise('arp', beat, 0.07, 0.88, 0.53);
    if (lastArpMidi !== null){
      const idx = degrees.indexOf(lastArpDegree);
      if (idx >= 0){
        if (directional > 0.66) deg = degrees[(idx + 1) % degrees.length];
        else if (directional < 0.34) deg = degrees[(idx + degrees.length - 1) % degrees.length];
      }
    }
    // avoid sharing pitch class with bass
    let tries = 0;
    while ( ((keyRoot + SCALES[scaleName][deg%7]) % 12) === lastBassPitchClass && tries++ < 6 ){
      deg = (deg + 2) % 7;
    }
    let m = midiFromKeyScaleDegree(keyRoot, scaleName, deg, 5);
    if (streamNoise('arp', beat, 0.052, 0.62, 0.91) > 0.7) m += 12;
    lastArpMidi = m;
    lastArpDegree = deg;
    return m;
  }

  function bassTimingOffset(beat){
    return (streamNoise('bass', beat, 0.19, 0.91, 0.22) - 0.5) * 0.045;
  }

  function applyNoiseModulations(beat, t){
    if (!ctx) return;
    const padBase = parseFloat(els.padCutoff.value);
    const padDelta = (streamNoise('timbre', beat, 0.012, 0.33, 0.45) - 0.5) * 480;
    if (padLP?.frequency){
      const target = clamp(padBase + padDelta, 200, 4000);
      try { padLP.frequency.linearRampToValueAtTime(target, t + 0.05); } catch {}
    }
    const echoBase = parseFloat(els.echoLP.value);
    const echoDelta = (streamNoise('timbre', beat, 0.016, 0.78, 0.14) - 0.5) * 720;
    if (echoLPF?.frequency){
      const target = clamp(echoBase + echoDelta, 800, 6000);
      try { echoLPF.frequency.setValueAtTime(target, Math.max(t, ctx.currentTime)); } catch {}
    }
    const widthBase = parseFloat(els.stereoWidth.value);
    const widthDelta = (streamNoise('space', beat, 0.008, 0.57, 0.66) - 0.5) * 0.22;
    setStereoWidth(clamp(widthBase + widthDelta, 0, 1));
    const beatBase = parseFloat(els.beat.value);
    const micro = (streamNoise('space', beat, 0.004, 0.19, 0.12) - 0.5) * 0.6;
    if (carrierLeft?.frequency && carrierRight?.frequency){
      const base = parseFloat(els.carrier.value);
      const targetTime = Math.max(t, ctx.currentTime);
      try {
        carrierLeft.frequency.linearRampToValueAtTime(base - (beatBase + micro) / 2, targetTime);
        carrierRight.frequency.linearRampToValueAtTime(base + (beatBase + micro) / 2, targetTime);
      } catch {}
    }
  }

  function ensureNoiseBuffer(){
    if (!ctx) return null;
    if (!noiseBuffer){
      const length = Math.max(1, Math.floor(ctx.sampleRate * 0.6));
      const buffer = ctx.createBuffer(1, length, ctx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < length; i++) data[i] = Math.random() * 2 - 1;
      noiseBuffer = buffer;
    }
    return noiseBuffer;
  }

  function humanizeHit(time, velocity, step, lane){
    if (!ctx) return { time, velocity };
    const human = parseFloat(els.drumHuman.value);
    if (!human) return { time, velocity };
    const spread = human * 0.04;
    const swingBase = streamNoise('drums', step, 0.19, lane === 'hat' ? 0.82 : lane === 'snare' ? 0.44 : 0.26, lane === 'kick' ? 0.31 : 0.67) - 0.5;
    const swing = swingBase * spread;
    const groovePhase = streamNoise('drumSync', step * 0.07 + (lane === 'hat' ? 0.93 : lane === 'snare' ? 1.71 : 0.37), 0.1, 0.63, lane === 'kick' ? 0.42 : 0.58) - 0.5;
    const offbeat = (step % 2) === 1;
    const syncShift = groovePhase * spread * (lane === 'hat' ? (offbeat ? 1.4 : 0.6) : lane === 'snare' ? 0.8 : 0.45);
    const pushPull = lane !== 'kick'
      ? (streamNoise('drumSync', step * 0.11 + 6.1, 0.09, lane === 'hat' ? 0.51 : 0.37, 0.71) - 0.5) * spread * 0.45
      : 0;
    const velDelta = (streamNoise('drumVel', step, 0.27, lane === 'hat' ? 0.55 : lane === 'snare' ? 0.72 : 0.34, lane === 'kick' ? 0.61 : 0.83) - 0.5) * (human * 0.5);
    const accent = streamNoise('drumAccent', step * 0.06 + (lane === 'hat' ? 2.5 : lane === 'snare' ? 1.2 : 0.4), 0.13, 0.57, 0.63) - 0.5;
    const accentScale = 1 + accent * (0.35 + human * 0.25);
    const t = Math.max(time + swing + syncShift + pushPull, ctx.currentTime + 0.0003);
    const v = clamp(velocity * accentScale + velDelta, 0.05, 1.0);
    return { time: t, velocity: v };
  }

  function scheduleKickHit(time, velocity){
    if (!ctx || !drumBus) return;
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type = 'sine';
    const startFreq = 90 + velocity * 50;
    osc.frequency.setValueAtTime(startFreq, time);
    osc.frequency.exponentialRampToValueAtTime(45, time + 0.12);
    gain.gain.setValueAtTime(0.0001, time);
    gain.gain.linearRampToValueAtTime(0.85 * velocity, time + 0.006);
    gain.gain.exponentialRampToValueAtTime(0.0001, time + 0.3);
    osc.connect(gain).connect(drumBus);
    osc.start(time);
    osc.stop(time + 0.35);
  }

  function scheduleSnareHit(time, velocity){
    if (!ctx || !drumBus) return;
    const noise = ctx.createBufferSource();
    noise.buffer = ensureNoiseBuffer();
    const filter = ctx.createBiquadFilter();
    filter.type = 'bandpass';
    filter.frequency.value = 1700 + velocity * 900;
    filter.Q.value = 0.8 + velocity * 0.6;
    const env = ctx.createGain();
    env.gain.setValueAtTime(0.0001, time);
    env.gain.linearRampToValueAtTime(0.8 * velocity, time + 0.005);
    env.gain.exponentialRampToValueAtTime(0.0001, time + 0.24);
    noise.connect(filter).connect(env).connect(drumBus);
    noise.start(time);
    noise.stop(time + 0.26);

    const tone = ctx.createOscillator();
    tone.type = 'triangle';
    tone.frequency.setValueAtTime(180 + velocity * 80, time);
    const toneGain = ctx.createGain();
    toneGain.gain.setValueAtTime(0.0001, time);
    toneGain.gain.linearRampToValueAtTime(0.5 * velocity, time + 0.01);
    toneGain.gain.exponentialRampToValueAtTime(0.0001, time + 0.22);
    tone.connect(toneGain).connect(drumBus);
    tone.start(time);
    tone.stop(time + 0.24);
  }

  function scheduleHatHit(time, velocity, open){
    if (!ctx || !drumBus) return;
    const src = ctx.createBufferSource();
    src.buffer = ensureNoiseBuffer();
    const hp = ctx.createBiquadFilter();
    hp.type = 'highpass';
    hp.frequency.value = 6000 + velocity * 3200;
    hp.Q.value = 0.9;
    const env = ctx.createGain();
    env.gain.setValueAtTime(0.0001, time);
    env.gain.linearRampToValueAtTime(0.6 * velocity, time + 0.004);
    const decay = open ? 0.25 : 0.1;
    env.gain.exponentialRampToValueAtTime(0.0001, time + decay);
    src.connect(hp).connect(env).connect(drumBus);
    src.start(time);
    src.stop(time + decay + 0.05);
  }

  function regenerateDrumPatterns(seedBeat=currentBeat){
    const steps = parseInt(els.drumLength.value, 10) || 16;
    drumPatternSteps = steps;
    const beats = Math.max(1, Math.floor(steps / DRUM_STEPS_PER_BEAT));
    const density = clamp(parseFloat(els.drumDensity.value) || 0, 0, 1);
    const fillChance = clamp(parseFloat(els.drumFill.value) || 0, 0, 1);
    const fillActive = Math.random() < fillChance;

    const section = Math.max(0, Math.floor((seedBeat || 0) / 16));
    const sectionRoot = section * 0.71 + 1.1;
    const syncFeel = streamNoise('drumSync', sectionRoot, 0.07, 0.68, 0.52);
    const accentFeel = streamNoise('drumAccent', sectionRoot + 2.4, 0.08, 0.54, 0.77);
    const hatFeel = streamNoise('drumSync', sectionRoot + 4.7, 0.05, 0.61, 0.83);
    const wantsBrokenBeat = syncFeel > 0.6;
    const wantsHalfTime = syncFeel < 0.24 && beats >= 4;
    const wantsStutter = accentFeel > 0.74;
    const hatTriplet = hatFeel > 0.58;
    const hatSkip = hatFeel < 0.28;
    const ghostStrength = 0.25 + accentFeel * 0.35;
    const accentMultiplier = 0.75 + accentFeel * 0.6;

    const kick = new Array(steps).fill(0);
    const snare = new Array(steps).fill(0);
    const hat = new Array(steps).fill(0);

    for (let i = 0; i < steps; i++){
      hat[i] = (i % 2 === 0) ? 0.55 : 0.35;
    }

    for (let beat = 0; beat < beats; beat++){
      const step = beat * DRUM_STEPS_PER_BEAT;
      const patternBeat = beat % 4;
      const beatNoise = sectionRoot + beat * 0.43;

      const kickAnchor = wantsHalfTime ? (patternBeat === 0 || patternBeat === 2) : (patternBeat === 0 || patternBeat === 2);
      if (kickAnchor){
        const basePower = patternBeat === 0 ? 0.96 : 0.82;
        kick[step] = Math.max(kick[step], basePower);
      }
      if (!wantsHalfTime && patternBeat === 0 && density > 0.25){
        const ghost = (step + DRUM_STEPS_PER_BEAT - 1) % steps;
        kick[ghost] = Math.max(kick[ghost], 0.45 + density * 0.25);
      }
      if (density > 0.48){
        const syncIntensity = streamNoise('drumSync', beatNoise, 0.12, 0.79, 0.41);
        if (syncIntensity > 0.52){
          const syncOffset = (step + Math.round(DRUM_STEPS_PER_BEAT * (syncIntensity > 0.78 ? 1.5 : 0.75))) % steps;
          kick[syncOffset] = Math.max(kick[syncOffset], 0.48 + density * 0.35);
        }
      }

      if (wantsHalfTime){
        if (patternBeat === 2){
          snare[step] = Math.max(snare[step], 0.92);
          if (density > 0.32){
            const drag = (step + DRUM_STEPS_PER_BEAT - 1) % steps;
            snare[drag] = Math.max(snare[drag], 0.35 + ghostStrength * 0.25);
          }
        }
      } else if (patternBeat === 1 || patternBeat === 3){
        const base = patternBeat === 1 ? 0.82 : 0.88;
        snare[step] = Math.max(snare[step], base);
        if (density > 0.45){
          const flamOffset = (step + DRUM_STEPS_PER_BEAT - 1) % steps;
          snare[flamOffset] = Math.max(snare[flamOffset], 0.35 + density * 0.25);
        }
      }

      if (density > 0.35 && patternBeat === 3){
        const openHatStep = (step + DRUM_STEPS_PER_BEAT - 1) % steps;
        hat[openHatStep] = Math.max(hat[openHatStep], 0.75);
      }

      if (wantsBrokenBeat){
        const anticipation = (step + Math.round(DRUM_STEPS_PER_BEAT * 0.5)) % steps;
        snare[anticipation] = Math.max(snare[anticipation], 0.32 + ghostStrength * 0.4);
        if (density > 0.55){
          const lateKick = (step + Math.round(DRUM_STEPS_PER_BEAT * 1.25)) % steps;
          kick[lateKick] = Math.max(kick[lateKick], 0.5 + density * 0.28);
        }
      }
    }

    if (fillActive && beats >= 2){
      const fillBeatStart = (beats - 1) * DRUM_STEPS_PER_BEAT;
      for (let i = 0; i < DRUM_STEPS_PER_BEAT; i++){
        const idx = (fillBeatStart + i) % steps;
        const progress = i / Math.max(1, DRUM_STEPS_PER_BEAT - 1);
        snare[idx] = Math.max(snare[idx], 0.45 + progress * 0.4);
        hat[idx] = Math.max(hat[idx], 0.65 + progress * 0.2);
      }
      const finalCrash = (fillBeatStart + DRUM_STEPS_PER_BEAT) % steps;
      hat[finalCrash] = Math.max(hat[finalCrash], 0.9);
    }

    for (let i = 0; i < steps; i++){
      const subStep = i % DRUM_STEPS_PER_BEAT;
      const localBeat = Math.floor(i / DRUM_STEPS_PER_BEAT);
      const hatAccentNoise = streamNoise('drumAccent', sectionRoot + i * 0.19, 0.17, 0.42, 0.68);
      const dropNoise = streamNoise('drumSync', sectionRoot + i * 0.23 + 1.7, 0.12, 0.51, 0.44);
      const accentBoost = 0.45 + hatAccentNoise * 0.4;
      if (subStep === 0){
        hat[i] = Math.max(hat[i], 0.5 + accentBoost * 0.5);
      } else if (subStep === 2){
        hat[i] = Math.max(hat[i], 0.42 + accentBoost * 0.35);
      }
      if (hatTriplet && subStep === 3){
        const follow = (i + 1) % steps;
        hat[follow] = Math.max(hat[follow], 0.52 + accentBoost * 0.28);
      }
      if (hatSkip && dropNoise < 0.36){
        hat[i] = Math.min(hat[i], 0.18 + dropNoise * 0.22);
      }
      if (wantsStutter && subStep === 1){
        const ghostIdx = (i + steps - 1) % steps;
        snare[ghostIdx] = Math.max(snare[ghostIdx], ghostStrength * 0.6);
      }
      if (hatAccentNoise > 0.78){
        const openTarget = (i + 1) % steps;
        hat[openTarget] = Math.max(hat[openTarget], 0.82 + hatAccentNoise * 0.12);
      }
      const syncRake = streamNoise('drumSync', sectionRoot + localBeat * 0.31 + subStep * 0.51, 0.09, 0.45, 0.7);
      if (syncRake > 0.64){
        const accentIdx = (i + Math.round(DRUM_STEPS_PER_BEAT * 0.5)) % steps;
        hat[accentIdx] = Math.max(hat[accentIdx], 0.58 + accentBoost * 0.3);
      }
      kick[i] = clamp(kick[i] * accentMultiplier, 0, 1);
      snare[i] = clamp(snare[i] * accentMultiplier, 0, 1);
      hat[i] = clamp(hat[i], 0, 1);
    }

    drumPatterns = { kick, snare, hat };
    drumPatternNeedsUpdate = false;
  }

  function scheduleDrumSteps(baseTime, beatIndex){
    if (!ctx || !drumBus || !els.drumToggle.checked) return;
    if (drumPatternNeedsUpdate || !drumPatterns) regenerateDrumPatterns(beatIndex);
    if (!drumPatterns) return;
    const steps = drumPatternSteps || 16;
    const stepDuration = BEAT_SEC / DRUM_STEPS_PER_BEAT;
    for (let s = 0; s < DRUM_STEPS_PER_BEAT; s++){
      const globalStep = drumStepCounter + s;
      const stepIndex = globalStep % steps;
      const scheduledTime = baseTime + s * stepDuration;
      const kickVel = drumPatterns.kick[stepIndex];
      if (kickVel > 0.05){
        const { time, velocity } = humanizeHit(scheduledTime, kickVel, beatIndex * DRUM_STEPS_PER_BEAT + s, 'kick');
        scheduleKickHit(time, velocity);
      }
      const snareVel = drumPatterns.snare[stepIndex];
      if (snareVel > 0.05){
        const { time, velocity } = humanizeHit(scheduledTime, snareVel, beatIndex * DRUM_STEPS_PER_BEAT + s + 11, 'snare');
        scheduleSnareHit(time, velocity);
      }
      const hatVel = drumPatterns.hat[stepIndex];
      if (hatVel > 0.05){
        const { time, velocity } = humanizeHit(scheduledTime, hatVel, beatIndex * DRUM_STEPS_PER_BEAT + s + 23, 'hat');
        scheduleHatHit(time, velocity, velocity > 0.82);
      }
    }
    drumStepCounter = (drumStepCounter + DRUM_STEPS_PER_BEAT) % steps;
    if (drumStepCounter === 0) drumPatternNeedsUpdate = true;
  }

  // ==== Scheduling voices ====
  function scheduleBass(t, midi){
    const osc = ctx.createOscillator(); const env = ctx.createGain();
    osc.type = els.bassWave.value; osc.frequency.setValueAtTime(midiToFreq(midi), t);
    env.gain.setValueAtTime(0.0001, t);
    env.gain.linearRampToValueAtTime(1.0, t+0.015);
    env.gain.exponentialRampToValueAtTime(0.25, t+0.12);
    env.gain.exponentialRampToValueAtTime(0.0001, t+0.32);
    osc.connect(env).connect(bassLP);
    osc.start(t); osc.stop(t+0.35);
  }

  function schedulePadChord(t, chordIndex){
    if (!els.padToggle.checked || !ctx) return;

    // Ensure pad voices exist if the scheduler fires early
    if (!padOscs || padOscs.length !== 3) {
      buildPadVoicesIfNeeded();
      // If still not ready (e.g., audio context not started), bail out
      if (!padOscs || padOscs.length !== 3) return;
    }

    const triad = TRIADS[chordIndex].map(d => midiFromKeyScaleDegree(keyRoot, scaleName, d, 3));
    for (let i = 0; i < padOscs.length; i++) {
      const hz = Math.max(1, midiToFreq(triad[i]));
      const v = padOscs[i];
      if (!v?.osc || !v?.env) continue;
      try {
        v.osc.frequency.cancelScheduledValues(t);
        v.osc.frequency.exponentialRampToValueAtTime(hz, t + 0.12);
        v.env.gain.cancelScheduledValues(t);
        v.env.gain.setTargetAtTime(0.6, t, 0.15);
      } catch {}
    }
  }

  function scheduleArp(t, beat){
    if (!els.arpToggle.checked) return;
    const osc = ctx.createOscillator(); const env = ctx.createGain();
    const m = pickArpMidi(currentChord, beat);
    osc.type = els.arpWave.value; osc.frequency.setValueAtTime(midiToFreq(m), t);
    env.gain.setValueAtTime(0.0001, t);
    const attack = 0.008 + streamNoise('arp', beat, 0.18, 0.27, 0.74) * 0.01;
    const decay = 0.12 + streamNoise('arp', beat, 0.14, 0.51, 0.39) * 0.08;
    env.gain.linearRampToValueAtTime(0.9, t + attack);
    env.gain.exponentialRampToValueAtTime(0.0001, t + decay);
    osc.connect(env).connect(arpBus);
    osc.start(t);
    osc.stop(t + decay + 0.04);
  }

  function scheduleLeadNote(t, midi, velocity=0.85, lengthSteps=LEAD_STEPS_PER_BEAT){
    if (!ctx || !leadBus || !leadState.enabled || !els.leadToggle.checked) return;
    const osc = ctx.createOscillator();
    const env = ctx.createGain();
    const freq = midiToFreq(midi);
    const clampedVel = clamp(velocity, 0.05, 1.0);
    const gate = Math.max(1, lengthSteps || 1) * (BEAT_SEC / LEAD_STEPS_PER_BEAT);
    const sustainTime = t + Math.max(0.05, gate * 0.72);
    const release = Math.max(0.1, gate * 0.45);
    osc.type = els.leadWave.value;
    osc.frequency.setValueAtTime(freq, t);
    env.gain.setValueAtTime(0.0001, t);
    env.gain.linearRampToValueAtTime(clampedVel, t + Math.min(0.06, gate * 0.25));
    env.gain.setValueAtTime(clampedVel, sustainTime);
    env.gain.exponentialRampToValueAtTime(0.0001, sustainTime + release);
    osc.connect(env).connect(leadBus);
    osc.start(t);
    osc.stop(sustainTime + release + 0.05);
  }

  function resetLeadGenerator(){
    leadGenState.phrase = [];
    leadGenState.steps = 0;
    leadGenState.stepIndex = 0;
    leadGenState.repeatsRemaining = 0;
    leadGenState.sectionIndex = 0;
    leadGenState.lastDegree = TRIADS[currentChord]?.[0] ?? 0;
    leadGenState.noiseCursor = Math.random() * 512;
    if (leadGenState.brownian){
      leadGenState.brownian.reset(leadGenState.lastDegree);
    }
  }

  function invalidateLeadGenerator(){
    leadGenState.phrase = [];
    leadGenState.steps = 0;
    leadGenState.stepIndex = 0;
    if (leadGenState.brownian && Number.isFinite(leadGenState.lastDegree)){
      leadGenState.brownian.snap(leadGenState.lastDegree);
    }
  }

  function buildLeadPhrase(){
    const section = leadGenState.sectionIndex || 0;
    const baseBeatsNoise = streamNoise('leadDensity', leadGenState.noiseCursor + section * 0.37, 0.03, 0.44, 0.76);
    const phraseBeats = 4 + Math.round(baseBeatsNoise * 4);
    const steps = Math.max(16, phraseBeats * LEAD_STEPS_PER_BEAT);
    const pattern = Array.from({ length: steps }, () => []);
    const scaleSteps = SCALES[scaleName] || SCALES.major;
    const octaveBase = parseInt(els.leadOct.value, 10) || 4;
    const chordDegrees = TRIADS[currentChord] || [0, 2, 4];
    let degree = Number.isFinite(leadGenState.lastDegree) ? leadGenState.lastDegree : (chordDegrees[0] ?? 0);
    const restFloor = 0.26 - Math.min(0.1, section * 0.02);
    const restCeil = restFloor + 0.22;
    const restTarget = restFloor + streamNoise('leadDensity', leadGenState.noiseCursor + section * 1.7 + 4.2, 0.015, 0.63, 0.32) * (restCeil - restFloor);
    const phraseRoot = leadGenState.noiseCursor + section * 11.7;
    let wroteNote = false;
    const walker = leadGenState.brownian;
    if (walker && !walker.initialized){
      walker.reset(degree);
    }

    for (let step = 0; step < steps;){
      const densitySample = streamNoise('leadDensity', phraseRoot + step * 0.21, 0.18, 0.52, 0.64);
      if (densitySample < restTarget){
        const restSteps = 1 + Math.floor(streamNoise('leadDensity', phraseRoot + step * 0.19 + 7.3, 0.16, 0.34, 0.82) * 2);
        step += restSteps;
        continue;
      }

      const dirSample = streamNoise('leadContour', phraseRoot + step * 0.17, 0.12, 0.48, 0.79);
      const magSample = streamNoise('leadContour', phraseRoot + step * 0.17 + 2.9, 0.1, 0.28, 0.93);
      const leapSample = streamNoise('leadContour', phraseRoot + step * 0.13 + 8.4, 0.09, 0.69, 0.31);
      const chordBias = streamNoise('leadHarmony', phraseRoot + step * 0.18, 0.2, 0.57, 0.44);

      let anchor = degree;
      let anchorStrength = 0.04 + section * 0.012;
      if (chordBias > 0.7){
        const chordChoiceIdx = Math.floor(streamNoise('leadHarmony', phraseRoot + step * 0.18 + 5.1, 0.23, 0.63, 0.2) * chordDegrees.length) % chordDegrees.length;
        const chordDegree = chordDegrees[chordChoiceIdx];
        const desiredOct = Math.round((degree - chordDegree) / scaleSteps.length);
        anchor = chordDegree + desiredOct * scaleSteps.length;
        anchorStrength += 0.08 + (chordBias - 0.7) * 0.18;
      }

      const contourPush = (dirSample - 0.5) * (0.32 + section * 0.015);
      const stepScale = 0.55 + magSample * 1.1;
      let rawDegree = degree + contourPush;
      if (walker){
        rawDegree = walker.sample({
          anchor,
          bias: anchorStrength,
          stepScale,
          registerBias: contourPush * 0.6
        });
      }

      let targetDegree = Math.round(rawDegree);

      if (chordBias < 0.16){
        targetDegree += chordBias < 0.08 ? -1 : 1;
      }

      if (leapSample > 0.88){
        const leapDir = leapSample > 0.94 ? 1 : -1;
        const leapSize = leapSample > 0.97 ? 5 : 4;
        targetDegree += leapDir * leapSize;
      }

      targetDegree = clamp(targetDegree, -2, 18);
      if (walker) walker.snap(targetDegree);

      const lengthSample = streamNoise('leadLength', phraseRoot + step * 0.23, 0.17, 0.73, 0.58);
      let lengthSteps = 1 + Math.floor(lengthSample * 3);
      if (section > 1 && lengthSteps < 2 && streamNoise('leadLength', phraseRoot + step * 0.23 + 2.6, 0.22, 0.41, 0.68) > 0.62){
        lengthSteps += 1;
      }
      lengthSteps = Math.max(1, Math.min(lengthSteps, steps - step));

      const velocitySample = streamNoise('leadVelocity', phraseRoot + step * 0.27, 0.15, 0.36, 0.82);
      const velocity = clamp(0.6 + velocitySample * 0.32 + section * 0.018, 0.55, 0.98);
      const midi = midiFromKeyScaleDegree(keyRoot, scaleName, targetDegree, octaveBase);
      pattern[step].push({ midi, length: lengthSteps, velocity });
      wroteNote = true;

      const harmonyChance = streamNoise('leadHarmony', phraseRoot + step * 0.18 + 9.9, 0.21, 0.33, 0.71);
      if (harmonyChance > 0.78){
        const harmonyDegree = targetDegree + (harmonyChance > 0.92 ? 4 : 2);
        const harmonyMidi = midiFromKeyScaleDegree(keyRoot, scaleName, harmonyDegree, octaveBase);
        pattern[step].push({ midi: harmonyMidi, length: Math.max(1, lengthSteps - 1), velocity: clamp(velocity * 0.82, 0.45, 0.9) });
      }

      degree = targetDegree;
      step += lengthSteps;
    }

    if (!wroteNote){
      if (walker) walker.snap(degree);
      const fallbackMidi = midiFromKeyScaleDegree(keyRoot, scaleName, degree, octaveBase);
      pattern[0].push({ midi: fallbackMidi, length: Math.min(steps, 2), velocity: 0.72 });
    }

    const repeatNoise = streamNoise('leadDensity', phraseRoot + 77, 0.028, 0.42, 0.66);
    const repeats = 2 + Math.floor(repeatNoise * 3);
    return { pattern, steps, repeats, lastDegree: degree };
  }

  function ensureGenerativePhrase(force=false){
    if (leadGenState.mode !== 'generative') return false;
    if (force){
      const info = buildLeadPhrase();
      leadGenState.phrase = info.pattern;
      leadGenState.steps = info.steps;
      leadGenState.stepIndex = 0;
      leadGenState.repeatsRemaining = Math.max(0, (info.repeats || 1) - 1);
      leadGenState.lastDegree = info.lastDegree;
      leadGenState.sectionIndex++;
      return true;
    }

    const hasPhrase = Array.isArray(leadGenState.phrase) && leadGenState.steps > 0;
    if (!hasPhrase){
      return ensureGenerativePhrase(true);
    }
    if (leadGenState.stepIndex >= leadGenState.steps){
      if (leadGenState.repeatsRemaining > 0){
        leadGenState.stepIndex = 0;
        leadGenState.repeatsRemaining--;
        return true;
      }
      return ensureGenerativePhrase(true);
    }
    return true;
  }

  function leadGrooveShape(globalStep){
    const section = Math.max(0, Math.floor(globalStep / (LEAD_STEPS_PER_BEAT * 16)));
    const sectionRoot = section * 0.57 + 3.2;
    const localBeat = (globalStep / LEAD_STEPS_PER_BEAT) % 16;
    const swingSample = streamNoise('leadGroove', sectionRoot + localBeat * 0.11, 0.08, 0.64, 0.55) - 0.5;
    const syncSample = streamNoise('leadGroove', sectionRoot + globalStep * 0.07 + 5.1, 0.1, 0.53, 0.82) - 0.5;
    const accentSample = streamNoise('leadAccent', sectionRoot + globalStep * 0.05, 0.14, 0.59, 0.41) - 0.5;
    const sustainSample = streamNoise('leadGroove', sectionRoot + globalStep * 0.04 + 8.7, 0.16, 0.73, 0.38);
    const offbeat = (globalStep % LEAD_STEPS_PER_BEAT) >= (LEAD_STEPS_PER_BEAT / 2);
    const swingScale = offbeat ? 0.032 : 0.018;
    const syncScale = 0.012 + section * 0.0015;
    const timeOffset = clamp((swingSample * swingScale + syncSample * syncScale) * BEAT_SEC * (1.1 + section * 0.08), -0.045, 0.045);
    const velocityMul = clamp(1 + accentSample * 0.42 + (offbeat ? 0.08 : 0), 0.65, 1.38);
    const lengthMul = clamp(0.82 + sustainSample * 0.45 + (accentSample > 0.55 ? 0.08 : 0), 0.6, 1.35);
    return { timeOffset, velocityMul, lengthMul };
  }

  function scheduleGenerativeLead(baseTime, stepDuration, beatIndex){
    if (leadGenState.mode !== 'generative') return;
    for (let s = 0; s < LEAD_STEPS_PER_BEAT; s++){
      if (!ensureGenerativePhrase()) return;
      const idx = leadGenState.stepIndex;
      const events = leadGenState.phrase[idx] || [];
      if (events.length){
        const globalStep = beatIndex * LEAD_STEPS_PER_BEAT + s;
        const groove = leadGrooveShape(globalStep);
        const time = Math.max(baseTime + s * stepDuration + groove.timeOffset, ctx.currentTime + 0.0004);
        for (const ev of events){
          const lengthSteps = Math.max(1, Math.round(ev.length * groove.lengthMul));
          scheduleLeadNote(time, ev.midi, ev.velocity * groove.velocityMul, lengthSteps);
        }
      }
      leadGenState.stepIndex++;
      if (leadGenState.stepIndex >= leadGenState.steps){
        ensureGenerativePhrase();
      }
    }
  }

  function scheduleClick(t){
    if (!els.clickToggle.checked) return;
    const o = ctx.createOscillator(); const e = ctx.createGain();
    const barPos = currentBeat % 16;
    const freq = (barPos===0) ? 2200 : 1600;
    const peak = (barPos===0) ? 0.9 : 0.6;
    o.type="sine"; o.frequency.setValueAtTime(freq, t);
    e.gain.setValueAtTime(0.0001, t);
    e.gain.linearRampToValueAtTime(peak, t+0.005);
    e.gain.exponentialRampToValueAtTime(0.0001, t+0.06);
    o.connect(e).connect(clickBus);
    o.start(t); o.stop(t+0.08);
  }

  function scheduleLeadLoop(baseTime, beatIndex){
    if (!ctx || !leadBus || !leadState.enabled || !els.leadToggle.checked) return;
    const stepDuration = BEAT_SEC / LEAD_STEPS_PER_BEAT;
    if (leadGenState.mode === 'generative'){
      scheduleGenerativeLead(baseTime, stepDuration, beatIndex);
      return;
    }
    for (let s = 0; s < LEAD_STEPS_PER_BEAT; s++){
      const stepIndex = (leadStepCursor + s) % LEAD_TOTAL_STEPS;
      const events = leadBuffer[stepIndex];
      if (events && events.length){
        const globalStep = beatIndex * LEAD_STEPS_PER_BEAT + s;
        const groove = leadGrooveShape(globalStep);
        const time = Math.max(baseTime + s * stepDuration + groove.timeOffset, ctx.currentTime + 0.0004);
        for (const ev of events){
          const lengthSteps = Math.max(1, Math.round(ev.length * groove.lengthMul));
          scheduleLeadNote(time, ev.midi, ev.velocity * groove.velocityMul, lengthSteps);
        }
      }
    }
    leadStepCursor = (leadStepCursor + LEAD_STEPS_PER_BEAT) % LEAD_TOTAL_STEPS;
  }

  function getLeadStepFloat(time){
    if (!ctx || transportStartTime === null) return null;
    const elapsed = time - transportStartTime;
    const beatPos = elapsed / BEAT_SEC;
    if (!isFinite(beatPos)) return null;
    return beatPos * LEAD_STEPS_PER_BEAT;
  }

  function storeLeadEvent(startAbsStep, lengthSteps, midi, velocity=0.85){
    if (!Number.isFinite(startAbsStep) || !Number.isFinite(lengthSteps)) return;
    let remaining = Math.floor(lengthSteps);
    if (remaining <= 0) return;
    const vel = clamp(velocity, 0.05, 1.0);
    let stepIndex = ((startAbsStep % LEAD_TOTAL_STEPS) + LEAD_TOTAL_STEPS) % LEAD_TOTAL_STEPS;
    while (remaining > 0){
      const chunk = Math.min(remaining, LEAD_TOTAL_STEPS - stepIndex);
      leadBuffer[stepIndex].push({ midi, length: chunk, velocity: vel });
      remaining -= chunk;
      stepIndex = 0;
    }
  }

  function clearLeadBuffer(){
    for (const slot of leadBuffer){
      slot.length = 0;
    }
    leadState.active.clear();
  }

  function updateLeadRecordUI(forceOff=false){
    if (forceOff && leadState.recording){
      leadState.recording = false;
    }
    if (!els.leadRecord) return;
    els.leadRecord.textContent = leadState.recording ? 'Stop Recording' : 'Record Loop';
    els.leadRecord.classList.toggle('recording', leadState.recording);
  }

  function updateLeadControls(){
    leadState.enabled = !!els.leadToggle?.checked;
    const mode = els.leadMode ? els.leadMode.value : 'manual';
    leadGenState.mode = mode;
    const manual = mode === 'manual';
    if (!leadState.enabled || !manual){
      updateLeadRecordUI(true);
      leadState.active.clear();
    }
    if (els.leadRecord) els.leadRecord.disabled = !leadState.enabled || !manual;
    if (els.leadClear) els.leadClear.disabled = !leadState.enabled || !manual;
  }

  function toggleLeadRecording(){
    if (!leadState.enabled || leadGenState.mode !== 'manual') return;
    leadState.recording = !leadState.recording;
    updateLeadRecordUI();
  }

  function handleLeadModeChange(){
    const prevMode = leadGenState.mode;
    const nextMode = els.leadMode ? els.leadMode.value : 'manual';
    if (prevMode === nextMode) {
      updateLeadControls();
      return;
    }
    leadGenState.mode = nextMode;
    if (nextMode === 'generative'){
      leadState.recording = false;
      leadState.active.clear();
      resetLeadGenerator();
    }
    if (nextMode === 'manual'){
      leadState.active.clear();
    }
    updateLeadControls();
    if (nextMode === 'manual') updateLeadRecordUI(true);
  }

  function isTypingTarget(el){
    if (!el) return false;
    const tag = el.tagName;
    return tag === 'INPUT' || tag === 'SELECT' || tag === 'TEXTAREA' || el.isContentEditable;
  }

  function leadKeyId(e){
    return e.code || e.key;
  }

  function handleLeadKeyDown(e){
    if (e.repeat) return;
    if (!ctx || transportStartTime === null || !leadState.enabled) return;
    if (isTypingTarget(document.activeElement)) return;
    if (leadGenState.mode !== 'manual') return;
    const key = typeof e.key === 'string' ? e.key.toLowerCase() : '';
    if (!(key in KEYBOARD_DEGREES)) return;
    const stepFloat = getLeadStepFloat(ctx.currentTime);
    if (stepFloat === null) return;
    let targetAbsStep = Math.max(0, Math.ceil(stepFloat));
    let startTime = transportStartTime + (targetAbsStep / LEAD_STEPS_PER_BEAT) * BEAT_SEC;
    if (startTime < ctx.currentTime + 0.003){
      targetAbsStep += 1;
      startTime = transportStartTime + (targetAbsStep / LEAD_STEPS_PER_BEAT) * BEAT_SEC;
    }
    const octaveBase = parseInt(els.leadOct.value, 10) || 4;
    const degree = KEYBOARD_DEGREES[key];
    const midi = midiFromKeyScaleDegree(keyRoot, scaleName, degree, octaveBase);
    const velocity = 0.88;
    scheduleLeadNote(startTime, midi, velocity, LEAD_STEPS_PER_BEAT);
    const id = leadKeyId(e);
    if (!leadState.active.has(id)){
      leadState.active.set(id, {
        midi,
        startAbsStep: targetAbsStep,
        velocity,
        recording: leadState.recording,
      });
    }
    e.preventDefault();
  }

  function handleLeadKeyUp(e){
    if (leadGenState.mode !== 'manual') return;
    const id = leadKeyId(e);
    const info = leadState.active.get(id);
    if (!info) return;
    if (info.recording){
      const stepFloat = ctx && transportStartTime !== null ? getLeadStepFloat(ctx.currentTime) : null;
      let endAbsStep = info.startAbsStep + 1;
      if (stepFloat !== null){
        endAbsStep = Math.max(info.startAbsStep + 1, Math.ceil(stepFloat));
      }
      const length = Math.min(LEAD_TOTAL_STEPS, Math.max(1, endAbsStep - info.startAbsStep));
      storeLeadEvent(info.startAbsStep, length, info.midi, info.velocity);
    }
    leadState.active.delete(id);
  }

  function scheduler(){
    if (!ctx) return;
    while (nextNoteTime < ctx.currentTime + SCHEDULE_AHEAD){
      const beatInBar = currentBeat % 16;
      const changeBias = streamNoise('harmony', currentBeat, 0.024, 0.91, 0.38);
      const shouldChange = beatInBar === 0 || beatInBar === 8 ||
        (beatInBar === 4 && changeBias > 0.46) ||
        (beatInBar === 12 && changeBias > 0.58);
      if (shouldChange){
        currentChord = nextChordIndex(currentChord, currentBeat);
        schedulePadChord(nextNoteTime, currentChord);
      }

      // Bass each beat
      const midi = pickBassMidi(currentChord, currentBeat);
      const bassOffset = bassTimingOffset(currentBeat);
      const bassTime = Math.max(nextNoteTime + bassOffset, ctx.currentTime + 0.0005);
      scheduleBass(bassTime, midi);

      // Arp density: 1/beat, 2/beat (eighths), or 3/beat (triplet-ish)
      const density = parseInt(els.arpDensity.value,10);
      for(let i=0;i<density;i++){
        const subBeat = currentBeat + (i / Math.max(1, density));
        scheduleArp(nextNoteTime + i*(BEAT_SEC/density)*0.98, subBeat); // slight pre-bias feels snappy
      }

      scheduleLeadLoop(nextNoteTime, currentBeat);

      scheduleDrumSteps(nextNoteTime, currentBeat);

      scheduleClick(nextNoteTime);
      applyNoiseModulations(currentBeat, nextNoteTime);

      nextNoteTime += BEAT_SEC;
      currentBeat++;
    }
  }

  // ==== Transport ====
  function start(){
    if (!ctx) initAudio();
    nextNoteTime = ctx.currentTime + 0.05;
    currentBeat = 0;
    transportStartTime = nextNoteTime;
    lastArpMidi = null;
    lastArpDegree = 0;
    drumStepCounter = 0;
    drumPatternNeedsUpdate = true;
    drumCycleSeed = Math.floor(Math.random() * 9973);
    leadStepCursor = 0;
    leadState.active.clear();
    resetLeadGenerator();
    updateLeadRecordUI(true);
    timerID = setInterval(()=>scheduler(), LOOKAHEAD*1000);
    els.start.disabled = true; els.stop.disabled = false;
  }
  function stop(){
    if (!ctx) return;
    clearInterval(timerID); timerID = null;
    try { carrierLeft?.stop(); carrierRight?.stop(); } catch {}
    try { padOscs?.forEach(({osc}) => osc.stop()); } catch {}
    try { lfoOsc?.stop(); } catch {}
    ctx.close().catch(()=>{}).finally(()=>{
      ctx = null;
      // Keep the array but empty it; it will be rebuilt on next initAudio()
      padOscs = [];
      drumPatterns = null;
      noiseBuffer = null;
      transportStartTime = null;
      leadState.active.clear();
      resetLeadGenerator();
      updateLeadRecordUI(true);
      els.start.disabled = false;
      els.stop.disabled = true;
      els.meterBar.style.width = "0%";
    });
  }

  // ==== Presets ====
  const BINAURAL_PRESETS = {
    custom: null,
    delta: { carrier: 200, beat: 2 },
    theta: { carrier: 210, beat: 6 },
    alpha: { carrier: 220, beat: 10 },
    beta: { carrier: 230, beat: 18 },
    gamma: { carrier: 240, beat: 40 },
  };

  const PRESETS = {
    calm: ({key="C", scale="major", bpm=120, carrier=200, beat=8, carGain=0.22, pad=0.28, padCut=1100, lfoR=0.10, lfoD=220, bass=0.33, lp=340, echoT=0.22, echoF=0.35, echoLP=2800, sendPad=0.35, sendArp=0.55}) =>
      ({key,scale,bpm,carrier,beat,carGain,pad,padCut,lfoR,lfoD,bass,lp,echoT,echoF,echoLP,sendPad,sendArp}),
    steady: ({key="A", scale="minor", bpm=116, carrier=220, beat=10, carGain=0.24, pad=0.25, padCut=1200, lfoR=0.14, lfoD=260, bass=0.35, lp=360, echoT=0.24, echoF=0.38, echoLP=3000, sendPad=0.32, sendArp=0.52}) =>
      ({key,scale,bpm,carrier,beat,carGain,pad,padCut,lfoR,lfoD,bass,lp,echoT,echoF,echoLP,sendPad,sendArp}),
    alert: ({key="D", scale="dorian", bpm=126, carrier=260, beat=14, carGain=0.20, pad=0.22, padCut=1600, lfoR=0.25, lfoD=180, bass=0.30, lp=420, echoT=0.18, echoF=0.28, echoLP=3600, sendPad=0.28, sendArp=0.60}) =>
      ({key,scale,bpm,carrier,beat,carGain,pad,padCut,lfoR,lfoD,bass,lp,echoT,echoF,echoLP,sendPad,sendArp}),
    groove: ({key="G", scale="mixolydian", bpm=120, carrier=230, beat=12, carGain=0.25, pad=0.30, padCut=1500, lfoR=0.18, lfoD=240, bass=0.38, lp=380, echoT=0.26, echoF=0.40, echoLP=3200, sendPad=0.40, sendArp=0.58}) =>
      ({key,scale,bpm,carrier,beat,carGain,pad,padCut,lfoR,lfoD,bass,lp,echoT,echoF,echoLP,sendPad,sendArp}),
  };

  function applyPreset(name){
    const p = PRESETS[name]({});
    // Always set UI values
    els.keySelect.value = p.key; keyRoot = KEYS[p.key];
    els.scaleSelect.value = p.scale; scaleName = p.scale;
    els.bpm.value = p.bpm; setBpm(p.bpm);
    els.carrier.value = p.carrier; els.beat.value = p.beat;
    els.carrierGain.value = p.carGain; els.padGain.value = p.pad;
    els.padCutoff.value = p.padCut; els.lfoRate.value = p.lfoR; els.lfoDepth.value = p.lfoD;
    els.bassGain.value = p.bass; els.lpCutoff.value = p.lp;
    els.echoTime.value = p.echoT; els.echoFB.value = p.echoF; els.echoLP.value = p.echoLP;
    els.echoSendPad.value = p.sendPad; els.echoSendArp.value = p.sendArp;
    if (els.binauralPreset) els.binauralPreset.value = 'custom';

    // Only touch AudioNodes if we're running and nodes exist
    if (ctx) {
      if (carrierLeft && carrierRight) setCarrierFreqs();
      carrierGain?.gain?.setValueAtTime(p.carGain, ctx.currentTime);
      padGain?.gain?.setValueAtTime(p.pad, ctx.currentTime);
      padLP?.frequency?.setValueAtTime(p.padCut, ctx.currentTime);
      lfoOsc?.frequency?.setValueAtTime(p.lfoR, ctx.currentTime);
      lfoGain?.gain?.setValueAtTime(p.lfoD, ctx.currentTime);
      bassBus?.gain?.setValueAtTime(p.bass, ctx.currentTime);
      bassLP?.frequency?.setValueAtTime(p.lp, ctx.currentTime);
      echoDelay?.delayTime?.setValueAtTime(p.echoT, ctx.currentTime);
      echoFB?.gain?.setValueAtTime(p.echoF, ctx.currentTime);
      echoLPF?.frequency?.setValueAtTime(p.echoLP, ctx.currentTime);
      echoSendPad?.gain?.setValueAtTime(p.sendPad, ctx.currentTime);
      echoSendArp?.gain?.setValueAtTime(p.sendArp, ctx.currentTime);
    }
    invalidateLeadGenerator();
  }

  // ==== UI bindings ====
  els.start.addEventListener('click', start);
  els.stop.addEventListener('click', stop);
  els.applyPreset.addEventListener('click', ()=>applyPreset(els.preset.value));

  els.binauralPreset.addEventListener('change', ()=>{
    const choice = BINAURAL_PRESETS[els.binauralPreset.value];
    if (!choice) return;
    els.carrier.value = choice.carrier;
    els.beat.value = choice.beat;
    setCarrierFreqs();
  });

  els.bpm.addEventListener('input', e=> setBpm(e.target.value));

  els.carrier.addEventListener('input', setCarrierFreqs);
  els.beat.addEventListener('input', setCarrierFreqs);
  els.carrierWave.addEventListener('change', ()=>{ if(ctx){ carrierLeft.type=els.carrierWave.value; carrierRight.type=els.carrierWave.value; }});
  els.carrierGain.addEventListener('input', ()=>{ if(ctx) carrierGain.gain.setValueAtTime(parseFloat(els.carrierGain.value), ctx.currentTime); });

  els.keySelect.addEventListener('change', e=>{ keyRoot = KEYS[e.target.value]; invalidateLeadGenerator(); });
  els.scaleSelect.addEventListener('change', e=>{ scaleName = e.target.value; invalidateLeadGenerator(); });
  els.bassGain.addEventListener('input', ()=>{ if(ctx) bassBus.gain.setValueAtTime(parseFloat(els.bassGain.value), ctx.currentTime); });
  els.lpCutoff.addEventListener('input', ()=>{ if(ctx) bassLP.frequency.setValueAtTime(parseFloat(els.lpCutoff.value), ctx.currentTime); });
  els.bassWave.addEventListener('change', ()=>{}); els.bassOct.addEventListener('input', ()=>{});

  els.padToggle.addEventListener('change', ()=>{
    if (!ctx) return;
    const t = ctx.currentTime; const on = els.padToggle.checked;
    padOscs.forEach(({env})=>{
      env.gain.cancelScheduledValues(t);
      env.gain.setTargetAtTime(on?0.6:0.0001, t, 0.12);
    });
  });
  els.padGain.addEventListener('input', ()=>{ if(ctx) padGain.gain.setValueAtTime(parseFloat(els.padGain.value), ctx.currentTime); });
  els.padCutoff.addEventListener('input', ()=>{ if(ctx) padLP.frequency.setValueAtTime(parseFloat(els.padCutoff.value), ctx.currentTime); });
  els.padWave.addEventListener('change', ()=>{
    if (!ctx) return;
    if (!padOscs || padOscs.length !== 3) buildPadVoicesIfNeeded();
    padOscs.forEach(({osc}) => { try { osc.type = els.padWave.value; } catch {} });
  });

  els.lfoRate.addEventListener('input', ()=>{ if(ctx) lfoOsc.frequency.setValueAtTime(parseFloat(els.lfoRate.value), ctx.currentTime); });
  els.lfoDepth.addEventListener('input', ()=>{ if(ctx) lfoGain.gain.setValueAtTime(parseFloat(els.lfoDepth.value), ctx.currentTime); });

  els.arpToggle.addEventListener('change', ()=>{});
  els.arpGain.addEventListener('input', ()=>{ if(ctx) arpBus.gain.setValueAtTime(parseFloat(els.arpGain.value), ctx.currentTime); });
  els.arpDensity.addEventListener('input', ()=>{});
  els.arpWave.addEventListener('change', ()=>{});

  els.leadToggle.addEventListener('change', ()=>{ updateLeadControls(); });
  els.leadGain.addEventListener('input', ()=>{ if(ctx && leadBus) leadBus.gain.setValueAtTime(parseFloat(els.leadGain.value), ctx.currentTime); });
  els.leadWave.addEventListener('change', ()=>{});
  if (els.leadMode) els.leadMode.addEventListener('change', handleLeadModeChange);
  els.leadOct.addEventListener('input', ()=>{ invalidateLeadGenerator(); });
  els.leadRecord.addEventListener('click', (e)=>{ e.preventDefault(); if (els.leadRecord.disabled) return; toggleLeadRecording(); });
  els.leadClear.addEventListener('click', (e)=>{ e.preventDefault(); if (els.leadClear.disabled) return; clearLeadBuffer(); });

  const markDrumsDirty = ()=>{ drumPatternNeedsUpdate = true; };
  els.drumToggle.addEventListener('change', ()=>{ markDrumsDirty(); });
  els.drumLevel.addEventListener('input', ()=>{ if(ctx) drumBus.gain.setValueAtTime(parseFloat(els.drumLevel.value), ctx.currentTime); });
  els.drumDensity.addEventListener('input', markDrumsDirty);
  els.drumFill.addEventListener('input', markDrumsDirty);
  els.drumHuman.addEventListener('input', ()=>{});
  els.drumLength.addEventListener('change', ()=>{ drumStepCounter = 0; markDrumsDirty(); });

  els.clickToggle.addEventListener('change', ()=>{});
  els.clickGain.addEventListener('input', ()=>{ if(ctx) clickBus.gain.setValueAtTime(parseFloat(els.clickGain.value), ctx.currentTime); });

  els.echoTime.addEventListener('input', ()=>{ if(ctx) echoDelay.delayTime.setValueAtTime(parseFloat(els.echoTime.value), ctx.currentTime); });
  els.echoFB.addEventListener('input', ()=>{ if(ctx) echoFB.gain.setValueAtTime(parseFloat(els.echoFB.value), ctx.currentTime); });
  els.echoLP.addEventListener('input', ()=>{ if(ctx) echoLPF.frequency.setValueAtTime(parseFloat(els.echoLP.value), ctx.currentTime); });
  els.echoSendPad.addEventListener('input', ()=>{ if(ctx) echoSendPad.gain.setValueAtTime(parseFloat(els.echoSendPad.value), ctx.currentTime); });
  els.echoSendArp.addEventListener('input', ()=>{ if(ctx) echoSendArp.gain.setValueAtTime(parseFloat(els.echoSendArp.value), ctx.currentTime); });
  els.echoSendLead.addEventListener('input', ()=>{ if(ctx) echoSendLead.gain.setValueAtTime(parseFloat(els.echoSendLead.value), ctx.currentTime); });

  els.compToggle.addEventListener('change', ()=>{ if(ctx && initAudio.wireMaster) initAudio.wireMaster(); });
  els.stereoWidth.addEventListener('input', ()=> setStereoWidth(parseFloat(els.stereoWidth.value)));
  els.master.addEventListener('input', ()=>{ if(ctx) masterGain.gain.setValueAtTime(parseFloat(els.master.value), ctx.currentTime); });

  window.addEventListener('keydown', e=>{
    if (e.key===' ') { e.preventDefault(); if (els.start.disabled) stop(); else start(); }
  });

  window.addEventListener('keydown', handleLeadKeyDown);
  window.addEventListener('keyup', handleLeadKeyUp);

  // Default preset
  updateLeadControls();
  updateLeadRecordUI();
  applyPreset('calm');

})();
</script>
</body>
</html>
